// main.dart :
import 'package:flutter/material.dart';
import 'package:flutter_bloc/flutter_bloc.dart';
import 'package:firebase_core/firebase_core.dart';
import 'package:firebase_messaging/firebase_messaging.dart';
import 'package:garudclient/blocs/user/user_bloc.dart';
import 'package:garudclient/blocs/user/profile_bloc.dart';
import 'package:garudclient/navigation/auth_wrapper.dart';
import 'package:shared_preferences/shared_preferences.dart';
import 'firebase_options.dart';
import 'services/notification_service.dart';
import 'repositories/auth_repository.dart';
import 'blocs/auth/auth_bloc.dart';
import 'blocs/theme/theme_bloc.dart';
import 'blocs/theme/theme_state.dart';
import 'config/theme_config.dart';

void main() async {
  WidgetsFlutterBinding.ensureInitialized();
  
  await Firebase.initializeApp(options: DefaultFirebaseOptions.currentPlatform);
  
  // Register background message handler before initializing notifications
  FirebaseMessaging.onBackgroundMessage(NotificationService.handleBackgroundMessage);
  
  await NotificationService.initialize();
  
  // Initialize SharedPreferences
  final prefs = await SharedPreferences.getInstance();

  runApp(MyApp(prefs: prefs));
}

class MyApp extends StatelessWidget {
  final AuthRepository _authRepository = AuthRepository();
  final SharedPreferences prefs;

  MyApp({required this.prefs});

  @override
  Widget build(BuildContext context) {
    return MultiBlocProvider(
      providers: [
        BlocProvider<AuthBloc>(create: (_) => AuthBloc(_authRepository)),
        BlocProvider<UserBloc>(create: (_) => UserBloc()),
        BlocProvider<ThemeBloc>(create: (_) => ThemeBloc(prefs)),
        BlocProvider<ProfileBloc>(create: (_) => ProfileBloc()),
      ],
      child: BlocBuilder<ThemeBloc, ThemeState>(
        builder: (context, state) {
          return MaterialApp(
            title: 'Garud',
            theme: AppTheme.lightTheme,
            darkTheme: AppTheme.darkTheme,
            themeMode: state.isDarkMode ? ThemeMode.dark : ThemeMode.light,
            home: AuthWrapper(), // Use our new AuthWrapper instead of LoginPage
          );
        },
      ),
    );
  }
}



// blocs/auth/auth_bloc.dart :
import 'package:flutter_bloc/flutter_bloc.dart';
import 'package:firebase_auth/firebase_auth.dart';
import 'package:garudclient/repositories/auth_repository.dart';
import 'dart:async';
import 'auth_event.dart';
import 'auth_state.dart';

class AuthBloc extends Bloc<AuthEvent, AuthState> {
  final AuthRepository authRepository;
  late StreamSubscription<User?> _authStateSubscription;

  AuthBloc(this.authRepository) : super(AuthInitial()) {
    on<CheckAuthStatus>((event, emit) async {
      emit(AuthLoading());
      try {
        final isLoggedIn = await authRepository.isLoggedIn();
        if (isLoggedIn) {
          emit(AuthSuccess());
        } else {
          emit(AuthInitial());
        }
      } catch (e) {
        emit(AuthFailure(message: e.toString()));
      }
    });

    on<SignupRequested>((event, emit) async {
      emit(AuthLoading());
      try {
        await authRepository.signup(event.email, event.password);
        emit(AuthSuccess());
      } catch (e) {
        emit(AuthFailure(message: e.toString()));
      }
    });
    
    on<SignupWithGarudIdRequested>((event, emit) async {
      emit(AuthLoading());
      try {
        await authRepository.signupWithGarudId(
          event.email, 
          event.password, 
          event.garudId
        );
        emit(AuthSuccess());
      } catch (e) {
        emit(AuthFailure(message: e.toString()));
      }
    });

    on<LoginRequested>((event, emit) async {
      emit(AuthLoading());
      try {
        await authRepository.login(event.email, event.password);
        emit(AuthSuccess());
      } catch (e) {
        emit(AuthFailure(message: e.toString()));
      }
    });

    on<LogoutRequested>((event, emit) async {
      emit(AuthLoading());
      try {
        await authRepository.logout();
        emit(AuthInitial());
      } catch (e) {
        emit(AuthFailure(message: e.toString()));
      }
    });

    // Add this to check auth status when bloc initializes
    add(CheckAuthStatus());

    // Listen to Firebase Auth state changes
    _authStateSubscription = FirebaseAuth.instance.authStateChanges().listen((user) {
      if (user != null) {
        add(CheckAuthStatus());
      } else {
        add(CheckAuthStatus());
      }
    });
  }

  @override
  Future<void> close() {
    _authStateSubscription.cancel();
    return super.close();
  }
}



// blocs/auth/auth_event.dart :
abstract class AuthEvent {}

class CheckAuthStatus extends AuthEvent {}

class LoginRequested extends AuthEvent {
  final String email;
  final String password;

  LoginRequested({required this.email, required this.password});
}

class SignupRequested extends AuthEvent {
  final String email;
  final String password;

  SignupRequested({required this.email, required this.password});
}

class SignupWithGarudIdRequested extends AuthEvent {
  final String email;
  final String password;
  final String garudId;

  SignupWithGarudIdRequested({
    required this.email, 
    required this.password, 
    required this.garudId
  });
}

class LogoutRequested extends AuthEvent {}



// blocs/auth/auth_state.dart :
abstract class AuthState {}

class AuthInitial extends AuthState {}

class AuthLoading extends AuthState {}

class AuthSuccess extends AuthState {}

class AuthFailure extends AuthState {
  final String message;

  AuthFailure({required this.message});
}



// blocs/theme/theme_bloc.dart :
import 'package:flutter_bloc/flutter_bloc.dart';
import 'package:shared_preferences/shared_preferences.dart';
import 'theme_event.dart';
import 'theme_state.dart';

class ThemeBloc extends Bloc<ThemeEvent, ThemeState> {
  final SharedPreferences prefs;
  static const String _themeKey = 'is_dark_mode';

  ThemeBloc(this.prefs) : super(ThemeState(isDarkMode: prefs.getBool(_themeKey) ?? false)) {
    on<ToggleTheme>(_onToggleTheme);
  }

  void _onToggleTheme(ToggleTheme event, Emitter<ThemeState> emit) async {
    final newIsDarkMode = !state.isDarkMode;
    await prefs.setBool(_themeKey, newIsDarkMode);
    emit(state.copyWith(isDarkMode: newIsDarkMode));
  }
}



// blocs/theme/theme_event.dart :
abstract class ThemeEvent {}

class ToggleTheme extends ThemeEvent {}



// blocs/theme/theme_state.dart :
import 'package:flutter/material.dart';
import 'package:equatable/equatable.dart';

class ThemeState extends Equatable {
  final bool isDarkMode;

  const ThemeState({this.isDarkMode = false});

  ThemeState copyWith({bool? isDarkMode}) {
    return ThemeState(isDarkMode: isDarkMode ?? this.isDarkMode);
  }

  @override
  List<Object?> get props => [isDarkMode];
}



// blocs/user/profile_bloc.dart :
import 'package:flutter_bloc/flutter_bloc.dart';
import 'package:firebase_auth/firebase_auth.dart';
import 'package:cloud_firestore/cloud_firestore.dart';
import 'profile_event.dart';
import 'profile_state.dart';

class ProfileBloc extends Bloc<ProfileEvent, ProfileState> {
  final _auth = FirebaseAuth.instance;
  final _firestore = FirebaseFirestore.instance;

  ProfileBloc() : super(ProfileInitial()) {
    on<LoadProfile>(_onLoadProfile);
  }

  Future<void> _onLoadProfile(LoadProfile event, Emitter<ProfileState> emit) async {
    emit(ProfileLoading());
    try {
      final user = _auth.currentUser;
      if (user == null) throw Exception("User not logged in");
      
      final userDoc = await _firestore
          .collection('users')
          .doc(user.uid)
          .get();

      if (!userDoc.exists) {
        throw Exception("User data not found");
      }

      final userData = userDoc.data()!;
      
      emit(ProfileLoaded(
        email: user.email ?? '',
        garudId: userData['garudId'] ?? '',
      ));
    } catch (e) {
      emit(ProfileError(e.toString()));
    }
  }
}



// blocs/user/profile_event.dart :
abstract class ProfileEvent {}

class LoadProfile extends ProfileEvent {}



// blocs/user/profile_state.dart :
import 'package:equatable/equatable.dart';

abstract class ProfileState extends Equatable {
  const ProfileState();
  
  @override
  List<Object?> get props => [];
}

class ProfileInitial extends ProfileState {}

class ProfileLoading extends ProfileState {}

class ProfileLoaded extends ProfileState {
  final String email;
  final String garudId;
  
  const ProfileLoaded({
    required this.email,
    required this.garudId,
  });
  
  @override
  List<Object?> get props => [email, garudId];
}

class ProfileError extends ProfileState {
  final String message;
  
  const ProfileError(this.message);
  
  @override
  List<Object?> get props => [message];
}



// blocs/user/user_bloc.dart :
import 'package:bloc/bloc.dart';
import 'package:cloud_firestore/cloud_firestore.dart';
import 'package:firebase_auth/firebase_auth.dart';

import 'user_event.dart';
import 'user_state.dart';

class UserBloc extends Bloc<UserEvent, UserState> {
  UserBloc() : super(UserInitial()) {
    on<AddGuardianRequested>(_onAddGuardianRequested);
    on<FetchGuardiansRequested>(_onFetchGuardiansRequested);
    on<DeleteGuardianRequested>(_onDeleteGuardianRequested);
    on<FetchProtegesRequested>(_onFetchProtegesRequested);
    on<DeleteProtegeRequested>(_onDeleteProtegeRequested);
  }

  Future<void> _onAddGuardianRequested(
      AddGuardianRequested event, Emitter<UserState> emit) async {
    emit(GuardianAddInProgress());
    try {
      final currentUser = FirebaseAuth.instance.currentUser;
      if (currentUser == null) throw Exception("User not logged in");

      // Find the guardian user by email
      final querySnapshot = await FirebaseFirestore.instance
          .collection('users')
          .where('email', isEqualTo: event.guardianEmail)
          .limit(1)
          .get();

      if (querySnapshot.docs.isEmpty) {
        throw Exception("Guardian not found");
      }

      final guardianUid = querySnapshot.docs.first.id;

      if (guardianUid == currentUser.uid) {
        throw Exception("You can't add yourself as a guardian");
      }

      // Use a batch write to update both records atomically
      final batch = FirebaseFirestore.instance.batch();

      // Add guardian to current user's document
      final currentUserRef =
          FirebaseFirestore.instance.collection('users').doc(currentUser.uid);

      batch.update(currentUserRef, {
        'guardians': FieldValue.arrayUnion([guardianUid])
      });

      // Add current user as protege to guardian's document
      final guardianRef =
          FirebaseFirestore.instance.collection('users').doc(guardianUid);

      batch.update(guardianRef, {
        'proteges': FieldValue.arrayUnion([currentUser.uid])
      });

      // Commit the batch write
      await batch.commit();

      emit(GuardianAdded());
      add(FetchGuardiansRequested()); // refresh list
    } catch (e) {
      emit(GuardianAddFailed(e.toString()));
    }
  }

  Future<void> _onFetchGuardiansRequested(
      FetchGuardiansRequested event, Emitter<UserState> emit) async {
    emit(GuardiansLoadInProgress());
    try {
      final currentUser = FirebaseAuth.instance.currentUser;
      if (currentUser == null) throw Exception("User not logged in");

      final userDoc = await FirebaseFirestore.instance
          .collection('users')
          .doc(currentUser.uid)
          .get();

      final guardianUids =
          List<String>.from(userDoc.data()?['guardians'] ?? []);

      List<Map<String, String>> tempList = [];

      for (String uid in guardianUids) {
        final guardianDoc =
            await FirebaseFirestore.instance.collection('users').doc(uid).get();
        if (guardianDoc.exists && guardianDoc.data()?['email'] != null) {
          tempList.add({
            'uid': uid,
            'email': guardianDoc.data()!['email'],
          });
        }
      }

      emit(GuardiansLoaded(tempList));
    } catch (e) {
      emit(GuardianLoadFailed(e.toString()));
    }
  }

  Future<void> _onDeleteGuardianRequested(
      DeleteGuardianRequested event, Emitter<UserState> emit) async {
    try {
      final currentUser = FirebaseAuth.instance.currentUser;
      if (currentUser == null) throw Exception("User not logged in");

      // Use a batch write to update both records atomically
      final batch = FirebaseFirestore.instance.batch();

      // Remove guardian from current user's document
      final currentUserRef =
          FirebaseFirestore.instance.collection('users').doc(currentUser.uid);

      batch.update(currentUserRef, {
        'guardians': FieldValue.arrayRemove([event.uidToRemove])
      });

      // Remove current user as protege from guardian's document
      final guardianRef =
          FirebaseFirestore.instance.collection('users').doc(event.uidToRemove);

      batch.update(guardianRef, {
        'proteges': FieldValue.arrayRemove([currentUser.uid])
      });

      // Commit the batch write
      await batch.commit();

      add(FetchGuardiansRequested());
    } catch (e) {
      emit(GuardianDeleteFailed(e.toString()));
    }
  }

  Future<void> _onFetchProtegesRequested(
      FetchProtegesRequested event, Emitter<UserState> emit) async {
    emit(ProtegesLoadInProgress());
    try {
      final currentUser = FirebaseAuth.instance.currentUser;
      if (currentUser == null) throw Exception("User not logged in");

      final userDoc = await FirebaseFirestore.instance
          .collection('users')
          .doc(currentUser.uid)
          .get();

      final protegeUids = List<String>.from(userDoc.data()?['proteges'] ?? []);

      List<Map<String, String>> tempList = [];

      for (String uid in protegeUids) {
        final protegeDoc =
            await FirebaseFirestore.instance.collection('users').doc(uid).get();
        if (protegeDoc.exists && protegeDoc.data()?['email'] != null) {
          tempList.add({
            'uid': uid,
            'email': protegeDoc.data()!['email'],
          });
        }
      }

      emit(ProtegesLoaded(tempList));
    } catch (e) {
      emit(ProtegesLoadFailed(e.toString()));
    }
  }

  Future<void> _onDeleteProtegeRequested(
      DeleteProtegeRequested event, Emitter<UserState> emit) async {
    try {
      final currentUser = FirebaseAuth.instance.currentUser;
      if (currentUser == null) throw Exception("User not logged in");

      // Use a batch write to update both records atomically
      final batch = FirebaseFirestore.instance.batch();

      // Remove protege from current user's document
      final currentUserRef =
          FirebaseFirestore.instance.collection('users').doc(currentUser.uid);

      batch.update(currentUserRef, {
        'proteges': FieldValue.arrayRemove([event.uidToRemove])
      });

      // Remove current user as guardian from protege's document
      final protegeRef =
          FirebaseFirestore.instance.collection('users').doc(event.uidToRemove);

      batch.update(protegeRef, {
        'guardians': FieldValue.arrayRemove([currentUser.uid])
      });

      // Commit the batch write
      await batch.commit();

      add(FetchProtegesRequested());
    } catch (e) {
      emit(ProtegeDeleteFailed(e.toString()));
    }
  }
}



// blocs/user/user_event.dart :
import 'package:equatable/equatable.dart';

abstract class UserEvent extends Equatable {
  const UserEvent();
  @override
  List<Object> get props => [];
}

class AddGuardianRequested extends UserEvent {
  final String guardianEmail;
  const AddGuardianRequested(this.guardianEmail);
  @override
  List<Object> get props => [guardianEmail];
}

class FetchGuardiansRequested extends UserEvent {}

class DeleteGuardianRequested extends UserEvent {
  final String uidToRemove;
  const DeleteGuardianRequested(this.uidToRemove);
  @override
  List<Object> get props => [uidToRemove];
}

// New event for fetching proteges
class FetchProtegesRequested extends UserEvent {}

class DeleteProtegeRequested extends UserEvent {
  final String uidToRemove;
  const DeleteProtegeRequested(this.uidToRemove);
  @override
  List<Object> get props => [uidToRemove];
}



// blocs/user/user_state.dart :
import 'package:equatable/equatable.dart';

abstract class UserState extends Equatable {
  const UserState();
  @override
  List<Object?> get props => [];
}

class UserInitial extends UserState {}

// Guardian States
class GuardianAddInProgress extends UserState {}

class GuardianAdded extends UserState {}

class GuardianAddFailed extends UserState {
  final String message;
  const GuardianAddFailed(this.message);
  @override
  List<Object?> get props => [message];
}

class GuardiansLoadInProgress extends UserState {}

class GuardiansLoaded extends UserState {
  final List<Map<String, String>> guardians;
  const GuardiansLoaded(this.guardians);
  @override
  List<Object?> get props => [guardians];
}

class GuardianLoadFailed extends UserState {
  final String message;
  const GuardianLoadFailed(this.message);
  @override
  List<Object?> get props => [message];
}

class GuardianDeleteFailed extends UserState {
  final String message;
  const GuardianDeleteFailed(this.message);
  @override
  List<Object?> get props => [message];
}

// Protege States
class ProtegesLoadInProgress extends UserState {}

class ProtegesLoaded extends UserState {
  final List<Map<String, String>> proteges;
  const ProtegesLoaded(this.proteges);
  @override
  List<Object?> get props => [proteges];
}

class ProtegesLoadFailed extends UserState {
  final String message;
  const ProtegesLoadFailed(this.message);
  @override
  List<Object?> get props => [message];
}

class ProtegeDeleteFailed extends UserState {
  final String message;
  const ProtegeDeleteFailed(this.message);
  @override
  List<Object?> get props => [message];
}



// config/theme_config.dart :
import 'package:flutter/material.dart';

class AppTheme {
  static ThemeData get lightTheme {
    return ThemeData(
      useMaterial3: true,
      brightness: Brightness.light,
      colorScheme: ColorScheme.light(
        primary: Colors.blue.shade700,
        secondary: Colors.blue.shade500,
        surface: Colors.white,
        background: Colors.grey.shade50,
        error: Colors.red.shade700,
      ),
      appBarTheme: AppBarTheme(
        elevation: 0,
        centerTitle: true,
        backgroundColor: Colors.blue.shade700,
        foregroundColor: Colors.white,
      ),
      elevatedButtonTheme: ElevatedButtonThemeData(
        style: ElevatedButton.styleFrom(
          padding: const EdgeInsets.symmetric(horizontal: 24, vertical: 12),
          shape: RoundedRectangleBorder(
            borderRadius: BorderRadius.circular(8),
          ),
        ),
      ),
      inputDecorationTheme: InputDecorationTheme(
        border: OutlineInputBorder(
          borderRadius: BorderRadius.circular(8),
        ),
        filled: true,
        fillColor: Colors.grey.shade100,
      ),
      cardTheme: CardTheme(
        elevation: 2,
        shape: RoundedRectangleBorder(
          borderRadius: BorderRadius.circular(12),
        ),
      ),
    );
  }

  static ThemeData get darkTheme {
    return ThemeData(
      useMaterial3: true,
      brightness: Brightness.dark,
      colorScheme: ColorScheme.dark(
        primary: Colors.blue.shade300,
        secondary: Colors.blue.shade200,
        surface: Colors.grey.shade900,
        background: Colors.grey.shade900,
        error: Colors.red.shade300,
      ),
      appBarTheme: AppBarTheme(
        elevation: 0,
        centerTitle: true,
        backgroundColor: Colors.grey.shade900,
      ),
      elevatedButtonTheme: ElevatedButtonThemeData(
        style: ElevatedButton.styleFrom(
          padding: const EdgeInsets.symmetric(horizontal: 24, vertical: 12),
          shape: RoundedRectangleBorder(
            borderRadius: BorderRadius.circular(8),
          ),
        ),
      ),
      inputDecorationTheme: InputDecorationTheme(
        border: OutlineInputBorder(
          borderRadius: BorderRadius.circular(8),
        ),
        filled: true,
        fillColor: Colors.grey.shade800,
      ),
      cardTheme: CardTheme(
        elevation: 2,
        shape: RoundedRectangleBorder(
          borderRadius: BorderRadius.circular(12),
        ),
      ),
    );
  }
}



// data/models/user_model.dart :




// data/repositories/auth_repository.dart :




// navigation/auth_wrapper.dart :
import 'package:flutter/material.dart';
import 'package:flutter_bloc/flutter_bloc.dart';
import 'package:garudclient/screens/home_page.dart';
import 'package:garudclient/screens/login_page.dart';
import '../blocs/auth/auth_bloc.dart';
import '../blocs/auth/auth_state.dart';

class AuthWrapper extends StatelessWidget {
  const AuthWrapper({Key? key}) : super(key: key);

  @override
  Widget build(BuildContext context) {
    return BlocBuilder<AuthBloc, AuthState>(
      builder: (context, state) {
        if (state is AuthSuccess) {
          return const HomePage();
        } else if (state is AuthLoading) {
          return const Scaffold(
            body: Center(
              child: CircularProgressIndicator(),
            ),
          );
        } else {
          return LoginPage();
        }
      },
    );
  }
}



// repositories/auth_repository.dart :
import 'package:firebase_auth/firebase_auth.dart';
import 'package:cloud_firestore/cloud_firestore.dart';
import 'package:firebase_messaging/firebase_messaging.dart';

class AuthRepository {
  final FirebaseAuth _auth = FirebaseAuth.instance;
  final FirebaseFirestore _firestore = FirebaseFirestore.instance;

  // Check if user is already logged in
  Future<bool> isLoggedIn() async {
    return _auth.currentUser != null;
  }

  Future<void> login(String email, String password) async {
    final userCredential = await _auth.signInWithEmailAndPassword(
        email: email, password: password);

    String? token = await FirebaseMessaging.instance.getToken();

    if (token != null) {
      await _firestore
          .collection('users')
          .doc(userCredential.user!.uid)
          .set({'token': token}, SetOptions(merge: true));
    }
  }

  Future<void> signup(String email, String password) async {
    final userCredential = await _auth.createUserWithEmailAndPassword(
        email: email, password: password);

    String? token = await FirebaseMessaging.instance.getToken();

    if (token != null) {
      await _firestore
          .collection('users')
          .doc(userCredential.user!.uid)
          .set({
        'token': token,
        'email': email,
        'createdAt': FieldValue.serverTimestamp(),
        'guardians': [],   // Initialize empty guardians array
        'proteges': [],    // Initialize empty proteges array
      });
    }
  }
  
  Future<void> signupWithGarudId(String email, String password, String garudId) async {
    // Run validation checks again to ensure Garud ID is valid and not already assigned
    final validIdDoc = await _firestore
        .collection('garudIdMap')
        .doc('0')
        .get();
    
    if (!validIdDoc.exists) {
      throw Exception('Unable to verify Garud ID. Please try again later.');
    }
    
    final validIds = List<String>.from(validIdDoc.data()?['ValidGarudIDList'] ?? []);
    
    if (!validIds.contains(garudId)) {
      throw Exception('Invalid Garud ID. Please enter a valid ID.');
    }
    
    final assignedIdDoc = await _firestore
        .collection('garudIdMap')
        .doc(garudId)
        .get();
    
    if (assignedIdDoc.exists) {
      throw Exception('This Garud ID is already assigned to another user.');
    }
    
    // Create the user account
    final userCredential = await _auth.createUserWithEmailAndPassword(
        email: email, password: password);
    
    // Get FCM token for notifications
    String? token = await FirebaseMessaging.instance.getToken();
    
    // Use a batch write to ensure consistency
    final batch = _firestore.batch();
    
    // Create the user document
    final userRef = _firestore.collection('users').doc(userCredential.user!.uid);
    batch.set(userRef, {
      'token': token,
      'email': email,
      'garudId': garudId,
      'createdAt': FieldValue.serverTimestamp(),
      'guardians': [],   // Initialize empty guardians array
      'proteges': [],    // Initialize empty proteges array
    });
    
    // Create the garudId mapping document
    final garudIdRef = _firestore.collection('garudIdMap').doc(garudId);
    batch.set(garudIdRef, {
      'uid': userCredential.user!.uid,
      'email': email,
      'assignedAt': FieldValue.serverTimestamp(),
    });
    
    // Commit the batch
    await batch.commit();
  }

  Future<void> logout() async {
    await _auth.signOut();
  }
}



// screens/add_guardians_page.dart :
import 'package:flutter/material.dart';
import 'package:flutter_bloc/flutter_bloc.dart';
import '../blocs/user/user_bloc.dart';
import '../blocs/user/user_event.dart';
import '../blocs/user/user_state.dart';

class AddGuardianPage extends StatefulWidget {
  const AddGuardianPage({super.key});

  @override
  State<AddGuardianPage> createState() => _AddGuardianPageState();
}

class _AddGuardianPageState extends State<AddGuardianPage> {
  final TextEditingController _emailController = TextEditingController();

  @override
  void initState() {
    super.initState();
    context.read<UserBloc>().add(FetchGuardiansRequested());
  }

  void _submitGuardian() {
    final email = _emailController.text.trim();
    if (email.isNotEmpty) {
      context.read<UserBloc>().add(AddGuardianRequested(email));
    } else {
      ScaffoldMessenger.of(context).showSnackBar(
        const SnackBar(content: Text('Please enter an email')),
      );
    }
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(
        title: const Text('Add Guardian'),
        actions: [
          IconButton(
            icon: const Icon(Icons.refresh),
            onPressed: () => context.read<UserBloc>().add(FetchGuardiansRequested()),
            tooltip: 'Refresh Guardian List',
          ),
        ],
      ),
      body: BlocConsumer<UserBloc, UserState>(
        listener: (context, state) {
          if (state is GuardianAdded) {
            ScaffoldMessenger.of(context).showSnackBar(
              const SnackBar(content: Text('Guardian added successfully')),
            );
            _emailController.clear();
            
            // Refresh both lists when guardian is added successfully
            context.read<UserBloc>().add(FetchGuardiansRequested());
            context.read<UserBloc>().add(FetchProtegesRequested());
          } else if (state is GuardianAddFailed || state is GuardianDeleteFailed) {
            final message = (state as dynamic).message;
            ScaffoldMessenger.of(context).showSnackBar(
              SnackBar(content: Text(message)),
            );
          }
        },
        builder: (context, state) {
          final isLoading = state is GuardiansLoadInProgress || state is GuardianAddInProgress;

          return Padding(
            padding: const EdgeInsets.all(20),
            child: Column(
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [
                const Text(
                  'Current Guardians:',
                  style: TextStyle(fontSize: 16, fontWeight: FontWeight.bold),
                ),
                const SizedBox(height: 10),
                if (isLoading)
                  const Center(child: CircularProgressIndicator())
                else if (state is GuardiansLoaded && state.guardians.isEmpty)
                  const Text('No guardians added yet.')
                else if (state is GuardiansLoaded)
                  Expanded(
                    child: ListView.builder(
                      itemCount: state.guardians.length,
                      itemBuilder: (context, index) {
                        final guardian = state.guardians[index];
                        return ListTile(
                          leading: const Icon(Icons.person),
                          title: Text(guardian['email'] ?? ''),
                          trailing: IconButton(
                            icon: const Icon(Icons.delete, color: Colors.red),
                            onPressed: () {
                              context.read<UserBloc>().add(
                                DeleteGuardianRequested(guardian['uid']!)
                              );
                            },
                          ),
                        );
                      },
                    ),
                  ),
                const SizedBox(height: 30),
                TextField(
                  controller: _emailController,
                  decoration: const InputDecoration(
                    labelText: 'Guardian Email',
                    border: OutlineInputBorder(),
                  ),
                ),
                const SizedBox(height: 20),
                ElevatedButton(
                  onPressed: isLoading ? null : _submitGuardian,
                  child: isLoading
                      ? const SizedBox(
                          width: 20,
                          height: 20,
                          child: CircularProgressIndicator(strokeWidth: 2),
                        )
                      : const Text('Add Guardian'),
                ),
              ],
            ),
          );
        },
      ),
    );
  }
}



// screens/home_page.dart :
import 'package:firebase_auth/firebase_auth.dart';
import 'package:flutter/material.dart';
import 'package:flutter_bloc/flutter_bloc.dart';
import 'package:cloud_firestore/cloud_firestore.dart';
import '../blocs/user/user_bloc.dart';
import '../blocs/user/user_event.dart';
import '../blocs/user/user_state.dart';
import '../blocs/theme/theme_bloc.dart';
import '../blocs/theme/theme_event.dart';
import '../blocs/theme/theme_state.dart';
import 'login_page.dart';
import 'add_guardians_page.dart';
import 'profile_page.dart';

class HomePage extends StatefulWidget {
  const HomePage({super.key});

  @override
  State<HomePage> createState() => _HomePageState();
}

class _HomePageState extends State<HomePage>
    with SingleTickerProviderStateMixin {
  String? _garudId;
  bool _isLoading = true;
  late TabController _tabController;

  @override
  void initState() {
    super.initState();
    _tabController = TabController(length: 2, vsync: this);
    _loadUserData();
    // Fetch both guardians and proteges when page loads
    context.read<UserBloc>().add(FetchGuardiansRequested());
    context.read<UserBloc>().add(FetchProtegesRequested());
  }

  @override
  void dispose() {
    _tabController.dispose();
    super.dispose();
  }

  Future<void> _loadUserData() async {
    if (!mounted) return;
    setState(() {
      _isLoading = true;
    });

    try {
      final user = FirebaseAuth.instance.currentUser;
      if (user != null) {
        final userDoc = await FirebaseFirestore.instance
            .collection('users')
            .doc(user.uid)
            .get();

        if (userDoc.exists && userDoc.data()?['garudId'] != null) {
          if (!mounted) return;
          setState(() {
            _garudId = userDoc.data()!['garudId'];
          });
        }
      }
    } catch (e) {
      // Handle error silently
      print('Error loading user data: $e');
    } finally {
      if (!mounted) return;
      setState(() {
        _isLoading = false;
      });
    }
  }

  void _logout(BuildContext context) async {
    await FirebaseAuth.instance.signOut();
    Navigator.pushAndRemoveUntil(
      context,
      MaterialPageRoute(builder: (_) => LoginPage()),
      (route) => false,
    );
  }

  void _goToAddGuardianPage(BuildContext context) {
    Navigator.push(
      context,
      MaterialPageRoute(builder: (_) => const AddGuardianPage()),
    ).then((_) {
      // Refresh data when returning from add guardian page
      context.read<UserBloc>().add(FetchGuardiansRequested());
      context.read<UserBloc>().add(FetchProtegesRequested());
    });
  }

  void _navigateToProfile(BuildContext context) {
    Navigator.push(
      context,
      MaterialPageRoute(builder: (_) => const ProfilePage()),
    );
  }

  Widget _buildDrawer() {
    return Drawer(
      child: ListView(
        padding: EdgeInsets.zero,
        children: [
          DrawerHeader(
            decoration: BoxDecoration(
              color: Theme.of(context).colorScheme.primary,
            ),
            child: Column(
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [
                const CircleAvatar(
                  radius: 30,
                  child: Icon(Icons.person, size: 35),
                ),
                const SizedBox(height: 10),
                Text(
                  FirebaseAuth.instance.currentUser?.email ?? 'User',
                  style: const TextStyle(
                    color: Colors.white,
                    fontSize: 18,
                  ),
                ),
                if (_garudId != null)
                  Text(
                    'Garud ID: $_garudId',
                    style: const TextStyle(
                      color: Colors.white70,
                      fontSize: 14,
                    ),
                  ),
              ],
            ),
          ),
          ListTile(
            leading: const Icon(Icons.person),
            title: const Text('My Profile'),
            onTap: () {
              Navigator.pop(context); // Close the drawer
              Navigator.push(
                context,
                MaterialPageRoute(builder: (_) => const ProfilePage()),
              );
            },
          ),
          ListTile(
            leading: const Icon(Icons.group_add),
            title: const Text('Add Guardian'),
            onTap: () {
              Navigator.pop(context); // Close the drawer
              _goToAddGuardianPage(context);
            },
          ),
          ListTile(
            leading: const Icon(Icons.settings),
            title: const Text('Settings'),
            onTap: () {
              Navigator.pop(context); // Close the drawer
              // TODO: Implement settings page
            },
          ),
          const Divider(),
          ListTile(
            leading: const Icon(Icons.logout, color: Colors.red),
            title: const Text('Logout', style: TextStyle(color: Colors.red)),
            onTap: () {
              Navigator.pop(context); // Close the drawer
              _logout(context);
            },
          ),
        ],
      ),
    );
  }

  @override
  Widget build(BuildContext context) {
    final user = FirebaseAuth.instance.currentUser;

    return Scaffold(
      endDrawer: _buildDrawer(),
      appBar: AppBar(
        title: const Text('Home'),
        actions: [
          BlocBuilder<ThemeBloc, ThemeState>(
            builder: (context, state) {
              return IconButton(
                icon: Icon(state.isDarkMode ? Icons.light_mode : Icons.dark_mode),
                onPressed: () => context.read<ThemeBloc>().add(ToggleTheme()),
                tooltip: state.isDarkMode ? 'Switch to Light Mode' : 'Switch to Dark Mode',
              );
            },
          ),
          Builder(
            builder: (context) => IconButton(
              icon: const Icon(Icons.menu),
              onPressed: () => Scaffold.of(context).openEndDrawer(),
            ),
          ),
        ],
        bottom: TabBar(
          controller: _tabController,
          tabs: const [
            Tab(text: 'Guardians'),
            Tab(text: 'Proteges'),
          ],
        ),
      ),
      body: _isLoading
          ? const Center(child: CircularProgressIndicator())
          : Column(
              children: [
                Padding(
                  padding: const EdgeInsets.all(16.0),
                  child: Column(
                    children: [
                      Text('Welcome, ${user?.email ?? "User"}!',
                          style: const TextStyle(fontSize: 20)),
                      const SizedBox(height: 10),
                      if (_garudId != null)
                        Card(
                          child: Padding(
                            padding: const EdgeInsets.all(16.0),
                            child: Column(
                              children: [
                                const Text(
                                  'Your Garud ID',
                                  style: TextStyle(
                                    fontSize: 16,
                                    fontWeight: FontWeight.bold,
                                  ),
                                ),
                                const SizedBox(height: 8),
                                Text(
                                  _garudId!,
                                  style: const TextStyle(
                                    fontSize: 18,
                                    fontWeight: FontWeight.w500,
                                  ),
                                ),
                              ],
                            ),
                          ),
                        ),
                    ],
                  ),
                ),
                Expanded(
                  child: TabBarView(
                    controller: _tabController,
                    children: [
                      // Guardians Tab
                      _buildGuardiansTab(),
                      // Proteges Tab
                      _buildProtegesTab(),
                    ],
                  ),
                ),
              ],
            ),
      floatingActionButton: FloatingActionButton(
        onPressed: () => _goToAddGuardianPage(context),
        child: const Icon(Icons.group_add),
        tooltip: 'Add Guardian',
      ),
      bottomNavigationBar: BottomAppBar(
        child: Padding(
          padding: const EdgeInsets.symmetric(horizontal: 16.0),
          child: Row(
            mainAxisAlignment: MainAxisAlignment.spaceBetween,
            children: [
              ElevatedButton.icon(
                icon: const Icon(Icons.refresh),
                label: const Text('Refresh'),
                onPressed: () {
                  context.read<UserBloc>().add(FetchGuardiansRequested());
                  context.read<UserBloc>().add(FetchProtegesRequested());
                },
              ),
              ElevatedButton.icon(
                icon: const Icon(Icons.logout),
                label: const Text('Logout'),
                onPressed: () => _logout(context),
              ),
            ],
          ),
        ),
      ),
    );
  }

  Widget _buildGuardiansTab() {
    return BlocBuilder<UserBloc, UserState>(
      buildWhen: (previous, current) {
        return current is GuardiansLoaded ||
            current is GuardiansLoadInProgress ||
            current is GuardianLoadFailed;
      },
      builder: (context, state) {
        if (state is GuardiansLoadInProgress) {
          return const Center(child: CircularProgressIndicator());
        } else if (state is GuardiansLoaded) {
          if (state.guardians.isEmpty) {
            return const Center(
              child: Text('No guardians added yet.'),
            );
          }
          return ListView.builder(
            itemCount: state.guardians.length,
            itemBuilder: (BuildContext context, int index) {
              final guardian = state.guardians[index];
              return ListTile(
                leading: const CircleAvatar(
                  child: Icon(Icons.person),
                ),
                title: Text(guardian['email'] ?? ''),
                subtitle: const Text('Guardian'),
                trailing: IconButton(
                  icon: const Icon(Icons.delete, color: Colors.red),
                  onPressed: () {
                    context.read<UserBloc>().add(
                          DeleteGuardianRequested(guardian['uid']!),
                        );
                  },
                ),
              );
            },
          );
        } else if (state is GuardianLoadFailed) {
          return Center(
            child: Text('Error: ${state.message}'),
          );
        } else {
          return const Center(
            child: Text('Select the refresh button to load guardians.'),
          );
        }
      },
    );
  }

  // Updated _buildProtegesTab method in screens/home_page.dart
  Widget _buildProtegesTab() {
    return BlocConsumer<UserBloc, UserState>(
      // Changed from BlocBuilder to BlocConsumer
      listenWhen: (previous, current) {
        return current is ProtegeDeleteFailed;
      },
      listener: (context, state) {
        // Display error message if delete operation fails
        if (state is ProtegeDeleteFailed) {
          ScaffoldMessenger.of(context).showSnackBar(
            SnackBar(
                content: Text('Failed to remove protege: ${state.message}')),
          );
        }
      },
      buildWhen: (previous, current) {
        return current is ProtegesLoaded ||
            current is ProtegesLoadInProgress ||
            current is ProtegesLoadFailed;
      },
      builder: (context, state) {
        if (state is ProtegesLoadInProgress) {
          return const Center(child: CircularProgressIndicator());
        } else if (state is ProtegesLoaded) {
          if (state.proteges.isEmpty) {
            return const Center(
              child: Text(
                  'No proteges yet. Someone has to add you as their guardian.'),
            );
          }
          return ListView.builder(
            itemCount: state.proteges.length,
            itemBuilder: (BuildContext context, int index) {
              final protege = state.proteges[index];
              return ListTile(
                leading: const CircleAvatar(
                  backgroundColor: Colors.blue,
                  child: Icon(Icons.shield, color: Colors.white),
                ),
                title: Text(protege['email'] ?? ''),
                subtitle: const Text('Protege'),
                trailing: IconButton(
                  icon: const Icon(Icons.delete, color: Colors.red),
                  onPressed: () {
                    // Show confirmation dialog
                    showDialog(
                      context: context,
                      builder: (BuildContext dialogContext) {
                        return AlertDialog(
                          title: const Text('Remove Protege'),
                          content: Text(
                              'Are you sure you want to remove ${protege['email']} as your protege? This will also remove you as their guardian.'),
                          actions: [
                            TextButton(
                              child: const Text('Cancel'),
                              onPressed: () {
                                Navigator.of(dialogContext).pop();
                              },
                            ),
                            TextButton(
                              child: const Text('Remove'),
                              onPressed: () {
                                context.read<UserBloc>().add(
                                      DeleteProtegeRequested(protege['uid']!),
                                    );
                                Navigator.of(dialogContext).pop();

                                // Show a loading indicator while the deletion is being processed
                                ScaffoldMessenger.of(context)
                                    .showSnackBar(const SnackBar(
                                  content: Text('Removing protege...'),
                                  duration: Duration(seconds: 1),
                                ));
                              },
                            ),
                          ],
                        );
                      },
                    );
                  },
                ),
              );
            },
          );
        } else if (state is ProtegesLoadFailed) {
          return Center(
            child: Text('Error: ${state.message}'),
          );
        } else {
          return const Center(
            child: Text('Select the refresh button to load proteges.'),
          );
        }
      },
    );
  }
}



// screens/login_page.dart :
import 'package:flutter/material.dart';
import 'package:flutter_bloc/flutter_bloc.dart';
import '../blocs/auth/auth_bloc.dart';
import '../blocs/auth/auth_event.dart';
import '../blocs/auth/auth_state.dart';
import 'home_page.dart';
import 'signup_page.dart';

class LoginPage extends StatelessWidget {
  final _emailController = TextEditingController();
  final _passwordController = TextEditingController();

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(title: Text('Login')),
      body: BlocConsumer<AuthBloc, AuthState>(
        listener: (context, state) {
          if (state is AuthSuccess) {
            Navigator.pushAndRemoveUntil(
              context,
              MaterialPageRoute(builder: (_) => HomePage()),
              (route) => false, 
            );
          } else if (state is AuthFailure) {
            ScaffoldMessenger.of(context).showSnackBar(
              SnackBar(content: Text('Login failed: ${state.message}')),
            );
          }
        },
        builder: (context, state) {
          return Padding(
            padding: EdgeInsets.all(16),
            child: Column(children: [
              TextField(
                  controller: _emailController,
                  decoration: InputDecoration(
                    labelText: 'Email',
                    border: OutlineInputBorder(),
                  )),
              SizedBox(height: 16),
              TextField(
                  controller: _passwordController,
                  decoration: InputDecoration(
                    labelText: 'Password',
                    border: OutlineInputBorder(),
                  ),
                  obscureText: true),
              SizedBox(height: 24),
              state is AuthLoading
                  ? CircularProgressIndicator()
                  : ElevatedButton(
                      onPressed: () {
                        BlocProvider.of<AuthBloc>(context).add(LoginRequested(
                          email: _emailController.text.trim(),
                          password: _passwordController.text.trim(),
                        ));
                      },
                      child: Text('Login'),
                    ),
              SizedBox(height: 16),
              TextButton(
                onPressed: () {
                  Navigator.push(
                    context,
                    MaterialPageRoute(builder: (_) => SignupPage()),
                  );
                },
                child: Text('Don\'t have an account? Sign up'),
              ),
            ]),
          );
        },
      ),
    );
  }
}



// screens/profile_page.dart :
import 'package:flutter/material.dart';
import 'package:flutter_bloc/flutter_bloc.dart';
import '../blocs/auth/auth_bloc.dart';
import '../blocs/auth/auth_event.dart';
import '../blocs/user/profile_bloc.dart';
import '../blocs/user/profile_event.dart';
import '../blocs/user/profile_state.dart';

class ProfilePage extends StatefulWidget {
  const ProfilePage({Key? key}) : super(key: key);

  @override
  _ProfilePageState createState() => _ProfilePageState();
}

class _ProfilePageState extends State<ProfilePage> {
  @override
  void initState() {
    super.initState();
    context.read<ProfileBloc>().add(LoadProfile());
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(
        title: const Text('Profile'),
        actions: [
          IconButton(
            icon: const Icon(Icons.logout),
            onPressed: () {
              context.read<AuthBloc>().add(LogoutRequested());
            },
          ),
        ],
      ),
      body: BlocBuilder<ProfileBloc, ProfileState>(
        builder: (context, state) {
          if (state is ProfileLoading || state is ProfileInitial) {
            return const Center(child: CircularProgressIndicator());
          }
          
          if (state is ProfileError) {
            return Center(
              child: Column(
                mainAxisAlignment: MainAxisAlignment.center,
                children: [
                  Text('Error: ${state.message}'),
                  const SizedBox(height: 16),
                  ElevatedButton(
                    onPressed: () {
                      context.read<ProfileBloc>().add(LoadProfile());
                    },
                    child: const Text('Retry'),
                  ),
                ],
              ),
            );
          }
          
          if (state is ProfileLoaded) {
            return SingleChildScrollView(
              padding: const EdgeInsets.all(16),
              child: Column(
                crossAxisAlignment: CrossAxisAlignment.start,
                children: [
                  const Center(
                    child: CircleAvatar(
                      radius: 50,
                      backgroundColor: Colors.blue,
                      child: Icon(Icons.person, size: 50, color: Colors.white),
                    ),
                  ),
                  const SizedBox(height: 24),
                  const Text(
                    'Email',
                    style: TextStyle(fontWeight: FontWeight.bold),
                  ),
                  TextField(
                    readOnly: true,
                    controller: TextEditingController(text: state.email),
                    decoration: const InputDecoration(
                      hintText: 'Email',
                    ),
                  ),
                  const SizedBox(height: 16),
                  const Text(
                    'Garud ID',
                    style: TextStyle(fontWeight: FontWeight.bold),
                  ),
                  TextField(
                    readOnly: true,
                    controller: TextEditingController(text: state.garudId),
                    decoration: const InputDecoration(
                      hintText: 'Garud ID',
                    ),
                  ),
                  const SizedBox(height: 24),
                  Center(
                    child: FilledButton.icon(
                      onPressed: () {
                        // TODO: Implement edit profile later
                        ScaffoldMessenger.of(context).showSnackBar(
                          const SnackBar(
                            content: Text('Editing profile will be available soon'),
                          ),
                        );
                      },
                      icon: const Icon(Icons.edit),
                      label: const Text('Edit Profile'),
                    ),
                  ),
                ],
              ),
            );
          }
          
          return const Center(
            child: Text('Something went wrong'),
          );
        },
      ),
    );
  }
}



// screens/signup_page.dart :
import 'package:flutter/material.dart';
import 'package:flutter_bloc/flutter_bloc.dart';
import 'package:cloud_firestore/cloud_firestore.dart';
import '../blocs/auth/auth_bloc.dart';
import '../blocs/auth/auth_event.dart';
import '../blocs/auth/auth_state.dart';
import 'home_page.dart';
import 'login_page.dart';

class SignupPage extends StatefulWidget {
  @override
  _SignupPageState createState() => _SignupPageState();
}

class _SignupPageState extends State<SignupPage> {
  final _emailController = TextEditingController();
  final _passwordController = TextEditingController();
  final _garudIdController = TextEditingController();
  bool _isValidatingId = false;
  String? _garudIdError;

  @override
  void dispose() {
    _emailController.dispose();
    _passwordController.dispose();
    _garudIdController.dispose();
    super.dispose();
  }
  
  Future<bool> _validateGarudId(String garudId) async {
    setState(() {
      _isValidatingId = true;
      _garudIdError = null;
    });
    
    try {
      // Check if the ID exists in the ValidGarudIDList
      final validIdSnapshot = await FirebaseFirestore.instance
          .collection('garudIdMap')
          .doc('0')
          .get();
      
      if (!validIdSnapshot.exists) {
        setState(() {
          _isValidatingId = false;
          _garudIdError = 'Unable to verify Garud ID. Please try again later.';
        });
        return false;
      }
      
      final validIds = List<String>.from(validIdSnapshot.data()?['ValidGarudIDList'] ?? []);
      
      if (!validIds.contains(garudId)) {
        setState(() {
          _isValidatingId = false;
          _garudIdError = 'Invalid Garud ID. Please enter a valid ID.';
        });
        return false;
      }
      
      // Check if the ID is already assigned to another user
      final assignedIdSnapshot = await FirebaseFirestore.instance
          .collection('garudIdMap')
          .doc(garudId)
          .get();
      
      if (assignedIdSnapshot.exists) {
        setState(() {
          _isValidatingId = false;
          _garudIdError = 'This Garud ID is already assigned to another user.';
        });
        return false;
      }
      
      setState(() {
        _isValidatingId = false;
      });
      return true;
    } catch (e) {
      setState(() {
        _isValidatingId = false;
        _garudIdError = 'Error validating Garud ID: ${e.toString()}';
      });
      return false;
    }
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(
        title: Text('Sign Up'),
      ),
      body: BlocConsumer<AuthBloc, AuthState>(
        listener: (context, state) {
          if (state is AuthSuccess) {
            Navigator.pushReplacement(
              context,
              MaterialPageRoute(builder: (_) => HomePage()),
            );
          } else if (state is AuthFailure) {
            ScaffoldMessenger.of(context).showSnackBar(
              SnackBar(content: Text('Signup failed: ${state.message}')),
            );
          }
        },
        builder: (context, state) {
          return SingleChildScrollView(
            padding: EdgeInsets.all(16),
            child: Column(
              mainAxisAlignment: MainAxisAlignment.center,
              children: [
                TextField(
                  controller: _emailController,
                  decoration: InputDecoration(
                    labelText: 'Email',
                    border: OutlineInputBorder(),
                  ),
                  keyboardType: TextInputType.emailAddress,
                ),
                SizedBox(height: 16),
                TextField(
                  controller: _passwordController,
                  decoration: InputDecoration(
                    labelText: 'Password',
                    border: OutlineInputBorder(),
                  ),
                  obscureText: true,
                ),
                SizedBox(height: 16),
                TextField(
                  controller: _garudIdController,
                  decoration: InputDecoration(
                    labelText: 'Garud ID',
                    border: OutlineInputBorder(),
                    errorText: _garudIdError,
                    helperText: 'Enter a valid Garud ID (e.g. Garud001)',
                  ),
                ),
                SizedBox(height: 24),
                state is AuthLoading || _isValidatingId
                    ? CircularProgressIndicator()
                    : ElevatedButton(
                        onPressed: () async {
                          final email = _emailController.text.trim();
                          final password = _passwordController.text.trim();
                          final garudId = _garudIdController.text.trim();
                          
                          if (email.isEmpty || password.isEmpty || garudId.isEmpty) {
                            ScaffoldMessenger.of(context).showSnackBar(
                              SnackBar(content: Text('Please fill in all fields')),
                            );
                            return;
                          }
                          
                          final isValidId = await _validateGarudId(garudId);
                          
                          if (isValidId) {
                            BlocProvider.of<AuthBloc>(context).add(
                              SignupWithGarudIdRequested(
                                email: email,
                                password: password,
                                garudId: garudId,
                              ),
                            );
                          }
                        },
                        child: Text('Sign Up'),
                      ),
                SizedBox(height: 16),
                TextButton(
                  onPressed: () {
                    Navigator.pushReplacement(
                      context,
                      MaterialPageRoute(builder: (_) => LoginPage()),
                    );
                  },
                  child: Text('Already have an account? Login'),
                ),
              ],
            ),
          );
        },
      ),
    );
  }
}



// services/fcm_service.dart :
import 'dart:convert';
import 'package:flutter/services.dart' show rootBundle;
import 'package:http/http.dart' as http;
import 'package:googleapis_auth/auth_io.dart' as auth;

class FCMService {
  static const _scopes = ['https://www.googleapis.com/auth/firebase.messaging'];

  Future<String> _getAccessToken() async {
    final serviceAccountJson =
        await rootBundle.loadString('assets/service_account.json');
    final credentials =
        auth.ServiceAccountCredentials.fromJson(json.decode(serviceAccountJson));
    final client = await auth.clientViaServiceAccount(credentials, _scopes);
    final accessToken = client.credentials.accessToken.data;
    client.close();
    return accessToken;
  }

  Future<void> sendNotification({
    required String targetToken,
    required String title,
    required String body,
  }) async {
    final accessToken = await _getAccessToken();
    final url =
        'https://fcm.googleapis.com/v1/projects/garud-21e17/messages:send';

    final message = {
      'message': {
        'token': targetToken,
        'notification': {'title': title, 'body': body},
      }
    };

    final response = await http.post(Uri.parse(url),
        headers: {
          'Content-Type': 'application/json',
          'Authorization': 'Bearer $accessToken',
        },
        body: jsonEncode(message));

    if (response.statusCode == 200) {
      print('Notification sent successfully');
    } else {
      print('Failed to send notification: ${response.statusCode}');
      print('Response body: ${response.body}');
    }
  }
}



// services/notification_service.dart :
import 'dart:io' show Platform;
import 'package:flutter/foundation.dart' show kIsWeb;
import 'package:firebase_messaging/firebase_messaging.dart';
import 'package:flutter_local_notifications/flutter_local_notifications.dart';

class NotificationService {
  static final FlutterLocalNotificationsPlugin _flutterLocalNotificationsPlugin =
      FlutterLocalNotificationsPlugin();
  
  static final AndroidNotificationChannel channel = AndroidNotificationChannel(
    'high_importance_channel', // id
    'High Importance Notifications', // title
    description: 'This channel is used for important notifications.', // description
    importance: Importance.high,
    playSound: true,
  );

  static Future<void> initialize() async {
    if (kIsWeb) return;

    // Request notification permissions
    await FirebaseMessaging.instance.requestPermission(
      alert: true,
      badge: true,
      sound: true,
    );

    // Initialize local notifications
    const AndroidInitializationSettings initializationSettingsAndroid =
        AndroidInitializationSettings('@mipmap/ic_launcher');
        
    final DarwinInitializationSettings initializationSettingsIOS =
        DarwinInitializationSettings(
      requestSoundPermission: true,
      requestBadgePermission: true,
      requestAlertPermission: true,
    );
    
    final InitializationSettings initializationSettings = InitializationSettings(
      android: initializationSettingsAndroid,
      iOS: initializationSettingsIOS,
    );
    
    await _flutterLocalNotificationsPlugin.initialize(
      initializationSettings,
      onDidReceiveNotificationResponse: (NotificationResponse details) async {
        print('Notification tapped: ${details.payload}');
      },
    );

    // Create notification channel
    if (!kIsWeb && Platform.isAndroid) {
      await _flutterLocalNotificationsPlugin
          .resolvePlatformSpecificImplementation<
              AndroidFlutterLocalNotificationsPlugin>()
          ?.createNotificationChannel(channel);
    }

    // Set up foreground notification presentation options
    await FirebaseMessaging.instance.setForegroundNotificationPresentationOptions(
      alert: true,
      badge: true,
      sound: true,
    );

    // Set up message handlers
    FirebaseMessaging.onMessage.listen(_handleForegroundMessage);
    FirebaseMessaging.onMessageOpenedApp.listen(_handleMessageOpenedApp);

    // Check for initial message
    final initialMessage = await FirebaseMessaging.instance.getInitialMessage();
    if (initialMessage != null) {
      _handleMessageOpenedApp(initialMessage);
    }
  }

  static Future<void> _handleForegroundMessage(RemoteMessage message) async {
    print("Got a message whilst in the foreground!");
    print("Message data: ${message.data}");

    if (message.notification != null) {
      await showNotification(
        message.notification?.title,
        message.notification?.body,
        message.data['payload'],
      );
    }
  }

  @pragma('vm:entry-point')
  static Future<void> handleBackgroundMessage(RemoteMessage message) async {
    print("Handling a background message: ${message.messageId}");
    
    if (message.notification != null) {
      await showNotification(
        message.notification?.title,
        message.notification?.body,
        message.data['payload'],
      );
    }
  }

  static void _handleMessageOpenedApp(RemoteMessage message) {
    print("Message opened app: ${message.data}");
    // Handle notification tap when app is in background/terminated
  }

  static Future<void> showNotification(
    String? title,
    String? body,
    String? payload,
  ) async {
    if (kIsWeb) return;

    await _flutterLocalNotificationsPlugin.show(
      DateTime.now().millisecond,
      title ?? 'Notification',
      body ?? 'No message body',
      NotificationDetails(
        android: AndroidNotificationDetails(
          channel.id,
          channel.name,
          channelDescription: channel.description,
          icon: '@mipmap/ic_launcher',
          importance: Importance.high,
          priority: Priority.high,
          showWhen: true,
        ),
        iOS: const DarwinNotificationDetails(
          presentAlert: true,
          presentBadge: true,
          presentSound: true,
        ),
      ),
      payload: payload,
    );
  }
}



